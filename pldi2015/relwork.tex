Program synthesis has received much attention from the programming
languages community lately. Many of these
efforts~\cite{sketch06,SrivastavaGF13,BCPR14} assume a
programmer-provided ``template'' of the target program. Some
others~\cite{completefunctional} do not need a template, but require a
full logical specification of the target program.  In contrast, our
method performs synthesis from input-output examples.
%system starts with input-output examples. 
%and automatically discovers the template.

Existing synthesis techniques that require only input-output examples  
%Quite a few approaches in this space do study example-guided program
%synthesis~\cite{MTGLK13,test-driven,recursive-synthesis,gulwani-string,gulwani-table,gulwani-number}.
%Most of these approaches 
are typically restricted to programs over basic data types like
numbers~\cite{gulwani-number}, strings~\cite{gulwani-string}, and
tables~\cite{gulwani-table}, as opposed to recursive data
structures. One exception is work by \cite{recursive-synthesis},
which, like our method, synthesizes recursive programs over data
structures. However, this approach is algorithmically quite different
from ours: while it uses enumerative search, it does not
use types, inductive generalization, or deduction. As we have shown in
\secref{eval}, these ideas are critical to the performance of our
approach.

The work described in~\cite{test-driven} gives a generic method for 
constructing program synthesizers for an arbirary user-defined domain-specific language
(DSL). While our synthesis problem could in principle be
expressed in that framework, their synthesis algorithm is
again based purely on enumerative search and therefore unlikely to
perform well on our experimental benchmarks.

%The difference of our work from \cite{test-driven}, who give a generic
%synthesizer for programs in a user-defined domain-specific language
%(DSL), is similar. Our synthesis problem could in principle be
%expressed in their framework.  However, their synthesis algorithm is
%based purely on enumerative search.

Example-guided synthesis has a long history in the artificial
intelligence
community~\cite{lieberman2001your,kitzelmann2,gulwani-ml}. Specifically,
we build on the tradition of {\em inductive
programming}~\cite{kitzelmann-survey,KitzelmannS06,ilp}, where the
goal is to synthesize functional or logic programs from examples. Work
here falls in two categories: those that inductively {\em generalize}
examples into functions or relations~\cite{KitzelmannS06}, and those
that {\em search} for implementations that fit the
examples~\cite{Katayama08,Olsson95}. Recent work by \cite{kitzelmann}
marries these two strands of research by restricting search to a space
of candidate programs obtained through generalization.  The main
difference between this approach and ours lies in the roles of search
and deduction.  Specifically, \cite{kitzelmann} uses deduction to
generate candidates for search --- i.e., each hypothesis must be
deduced from some parent hypothesis. In contrast, we use deduction of
examples as a {\em guide} to enumerative search. All hypotheses are
allowed unless proven otherwise, and if deduction fails, we fall back
on exhaustive search.  This is a critical advantage because deductive
inference is not necessarily applicable for every operator in a
programming languge.

Since our technique uses types to guide synthesis, another line of
related work is \emph{type-directed program synthesis}.  In
particular, several recent papers use type-guided search to
auto-complete program expressions involving complex API
calls~\cite{perelman2012,gvero2013,mandelin2005jungloid}.  For
instance, the {\sc InSynth} tool formulates the code completion
problem in terms of \emph{type inhabitation} and generates a
rank-ordered list of type inhabitants~\cite{gvero2013}.  While our
type-aware inductive generalization can be viewed as a form of type
inhabitation problem, we simply use it for pruning the search
space. Furthermore, rather than just finding a type inhabitant, our
goal is to synthesize a program that is consistent with the
input-output examples.

The technique we have proposed in this paper synthesizes a program
that is not only consistent with the provided examples but is also a
\emph{minimum-cost} one according to some cost metric.  Hence, our
approach bares similarity to other efforts for \emph{optimal program
synthesis}~\cite{bloem2009better,dilligoptimal,chaudhuri2014bridging}.
In addition to addressing a different synthesis domain, we propose a
different definition of \emph{optimality} in this paper.


% Our search strategy is more expansive than in
% \cite{kitzelmann}. Specifically, in \cite{kitzelmann}, each hypothesis
% must be deduced from some parent hypothesis, whereas our approach
% applies enumerative search when deduction fails. This is a critical
% advantage because rules for deduction are not necessarily available
% for every operator in a programming languge. A second difference is
% that we use deduction of examples as a pruning mechanism; all
% hypotheses are allowed unless we can prove otherwise. In contrast,
% \cite{kitzelmann} uses deduction to produce new candidates for search.

%Synthesizing such programs automatically would seem to be a natural
%technical problem. However, recent synthesis algorithms from the
%programming language community avoid this arena, instead focusing on
%programs over simple data types like numbers, bitvectors and
%strings. While researchers in the area of {\em inductive functional
%  programming} have considered the synthesis of programs over
%recursive data types, progress there stalled in the 1980s. Existing
%systems from that tradition tend to either lack scalability or be
%restricted to specialized data structures (mostly lists).