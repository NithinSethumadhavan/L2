The last few years have seen a flurry of research on {\em automated
  program
  synthesis}~\cite{sketch06,completefunctional,gulwani-dimensions,sygus,VechevYY13}. This
research area aims to radically simplify programming by allowing
users to express their intent as nondeterministic,
possibly-incomplete specifications.  An algorithmic {\em program
  synthesizer} is then used to discover executable implementations of
these specifications.

{\em Inductive synthesis from
  examples} is a
particularly important form of program synthesis~\cite{gulwani-string,lieberman2001your,kitzelmann2}. Here, a
specification consists of a set of examples of the form $a \mapsto b$,
where $a$ is a sample input and $b$ is the output of the desired
program on input $a$.  The synthesizer's task is to ``learn'' a
program from these examples. This form of synthesis is especially
appealing to end-users who need to perform programming tasks but lack
the expertise or time to write traditional code. A prominent
synthesizer of this sort is FlashFill, a feature of Excel 2013 that
can generate spreadsheet table transformations from
examples~\cite{gulwani-string}. Example-guided synthesis has also been
applied in many other application domains, ranging from bit-level
algorithms to geometry constructions %to gaming 
to text
editing~\cite{component-based,gulwani-geometry,lieberman2001your}.

In this paper, we present a method for example-guided synthesis of
programs that transform recursive data structures such as lists and trees. Such
programs arise in many end-user programming scenarios. For instance,
most professionals who work with numbers would sometimes want to
programmatically manipulate lists or tables of numbers.  Trees show up
in end-user applications in many guises --- concrete examples include
family trees, HTML/XML documents, and directory trees in file
systems. In fact, some end-user applications may demand data
structures that are more general than lists or trees. For instance, a
user interested in family trees may sometimes want to analyze trees
for an unbounded list of families. In a specific family tree, a node
for an individual may be equipped with a list of attributes for that
person, and the user may want to transform these lists.


\begin{comment}
% SC: I think the following is too specific. Plus, we now have an
% examples section.
Consider, for instance, the following scenarios:
\begin{itemize}
\item A user wants to modify the content of directories that match
  certain patterns. Since the directory structure
  can be viewed as a tree, the user effectively needs to write a
  script that maps an input tree to a new output tree.

\item Given a list of student homework scores, a high school teacher
  wants to drop the minimum score for each student.  To automate this
  task, the teacher must write a program that takes in a list
  consisting of lists $l_i$ (where $l_i$ contains the scores for the
  $i$-th student), and produces a new list of lists.

\item A social scientist has a list of answers to a survey question
  and wants to know how often a given answer appears. That is, given
  an input list of strings, she needs to produce an output list of
  (string, integer) pairs where the integer denotes the frequency of
  the corresponding string in the input list.
\end{itemize}
\end{comment}

Transformations of recursive data structures are naturally expressed
as functional programs. 
%Despite significant recent progress in program synthesis, the
%synthesis of data structure transformations like the above remains an
%under-studied problem. 
Therefore, our synthesis algorithm targets a functional programming
language that permits higher-order functions, combinators like {\tt
  map}, {\tt fold} and {\tt filter}, pattern-matching, recursion, and
a flexible set of primitive operators and constants. The input to our
algorithm is a set of input-output examples that define the behavior
of the target program on certain small-sized instances. On such an
input, the synthesis algorithm either times out or returns a program
that fits the examples. In the latter case, the synthesized program is
guaranteed to be the {\em least-cost} program in our language to fit
the examples, according a cost metric that assigns lower cost to
simpler programs (for example, programs that are free of conditional
branches).

A key advantage of the above optimality guarantee is that the
synthesized program is not over-fitted to the examples. Specifically,
given input-output examples $a_1 \mapsto b_1,\dots, a_n \mapsto b_n$,
our algorithm is unlikely to return a program that does an $n$-way
case split on its input and returns $b_i$ whenever the input is equal
to $a_i$. Instead, the algorithm tries to ``generalize'' the examples
into a program that makes minimal use of conditional branches.

Although the synthesis algorithm's job is fundamentally difficult due
to the combinatorial search space of possible programs, our algorithm
addresses this challenge using a combination of three technical ideas:
(1) {\em type-aware inductive generalization}, (2) the use of {\em
  deduction} to guide the solution of subproblems; and (3) {\em
  best-first enumerative search}.

\paragraph{Inductive generalization} Rather than blindly searching for a
target program, our method generalizes the user-provided examples
into a set of {\em hypotheses} about this program. A hypothesis is
either a concrete program or a ``skeleton'' that contains
placeholders (``holes'') for unknown programs. For instance, a
hypothesis $h$ for a program $e$ might be of the form
$\lambda x.\  \texttt{map}\  f^*\  x$
where $f^*$ stands for an unknown program. To synthesize a program from a
hypothesis, we must substitute holes such as $f^*$ by concrete programs.

Our algorithm generates hypotheses in a \emph{type-aware} manner: We infer a type  from the
input-output examples and only generate hypotheses that can be
concretized to programs of this type.  For instance, our algorithm
 generates the hypothesis $\lambda x.\  \texttt{map}\  f^*\  x$ %$h$ shown above 
only if all input-output
examples are of type ${\rm list}(\tau) \rightarrow {\rm
  list}(\tau)$. This strategy often leads to significant
pruning of the search space.

%the form $a \mapsto b$, where $a$ and
%$b$ are lists containing items of the same type. 

\paragraph{Deduction} 

Once our algorithm generates a hypothesis $h$ in the form of a program
skeleton, we must solve one or more subproblems in order to synthesize
the unknown functions that appear in $h$.  For this purpose, our
algorithm uses \emph{automated deduction} to efficiently find a
solution to the subproblems. In particular, we use deductive reasoning
in two ways:

\begin{itemize} 
\item {\bf \emph{Refutation.}} First, deduction is used to quickly \emph{refute} certain
hypotheses. %, thereby pruning the search space.  
For instance, consider
an example of the form $[1, 1] \mapsto [2, 3]$ and the hypothesis $ h
\equiv \lambda x.\ \texttt{map}\ f^*\ x$. Our deduction engine infers
that this hypothesis $h$ cannot  be appropriate in this case,
as no function maps the number 1 in the input list to two
distinct numbers 2 and 3 in the output list.

\item{\bf \emph{Example inference.}} Second, deduction is used to
  generate new examples that guide the search for missing
  functions. Consider again the hypothesis $\lambda x.\ \texttt{map}\
  f^*\ x$ and the example $[1, 2] \mapsto [3, 4]$. In this case, the
  deduction engine uses properties of the \texttt{map} combinator to
  infer two examples for $f^*$: $1 \mapsto 3$ and $2 \mapsto 4$.  To
  find $f^*$, we invoke the synthesis algorithm on these examples.
\end{itemize}

\paragraph{Best-first enumerative search} 
% In general, a set of examples will lead to multiple hypotheses, and a
% hypothesis will generate multiple synthesis subproblems. Not all of
% these subproblems will lead to fruitful results, and as a result, we
% may have to iterate over them. Also, in the base case of our synthesis
% procedure, we will have to search over a combinatorial space of
% concrete expressions made from operators and symbolic constants, and
% check that the resulting program is consistent with the input-output
% examples.

Whether we are solving the top-level synthesis problem or a
subproblem, we will eventually get to a point where inductive
generalization and deduction no longer help us. In this case, our
method falls back on {\em enumerative search}.  In particular, we
explore the space of all expressions that fit our hypothesis and check
whether the generated expressions are consistent with the provided
input-output examples. Also, we may find that a specific hypothesis
cannot be realized into a program that fits the examples. In this
case, our algorithm uses enumerative search to pick a new hypothesis.

Using the principle of \emph{Occam's razor}, our search algorithm
prioritizes simpler expressions and hypotheses. Specifically, the algorithm
maintains a ``frontier'' of candidate expressions and hypotheses that
need to be explored next and, at each point in the search, picks the
{\em least-cost} item from this frontier.
%(according to a
%structural simplicity metric) 
%over more complex ones. 
We show that this search strategy allows us synthesize the simplest
program that fits the examples.


\paragraph{Results} 

We have implemented our algorithm in a tool called \sys, and we
empirically demonstrate that our technical insights can be combined
into a scalable algorithm\footnote{The name \sys stands for ``Learning
  Lambdas"}. The benchmarks for our experiments include over 40 synthesis
problems involving lists, trees, and nested data structures such as
lists of lists and trees of lists. We show that \sys can successfully
solve these benchmarks, typically within a few seconds. 
%We evaluate \sys on these
%benchmarks and show that it can successfully synthesize many complex, yet elegant,
%programs, typically within a few seconds. 
%under two scenarios where the input examples are generated
%by (i) a random process and (ii) a human. In both scenarios, \sys
%returns within a few seconds on most of the benchmarks and within a
%few minutes on the most challenging benchmarks. 
The programs that \sys synthesizes can be complex but also elegant.
For example, \sys is able to synthesize a program that is believed to
be the world's earliest functional pearl~\cite{spivey-example}.

%Finally, we find \sys to be significantly
%faster than alternative methods that follow our basic approach but
%only use a subset of our technical ideas.
% [ID: I removed this claim because it gives the impression
% that there are other tools that can synthesize the same
% programs, just slower. I think this is both misleading
% and makes our approach not seem as novel.]

% [SC: I think the robustness thing is bogus -- some problems
% fundamentally need more examples -- not our tool's fault!]
%
% \sys is also shown to be robust, in the sense that it typically
% needs less than 5 randomly-generated examples to synthesize the
% intended programs.

\paragraph{Organization}

The paper is organized as follows. In \secref{example}, we present three
motivating examples for our approach. After formalizing the problem  in \secref{problem}, we
present our synthesis algorithm in  \secref{algo}. An evaluation is presented in
\secref{eval}, and related work is discussed in \secref{relwork}. Finally, we
conclude with some discussion in \secref{conc}. 
