open Core.Std

let catamorphic_solve_testcases =
  [
    ("car", ["(f [0]) -> 0";
             "(f [1 0]) -> 1";
             "(f [2 1 0]) -> 2";
            ], []),
    "";

    ("cdr", ["(f [0]) -> []";
             "(f [1 0]) -> [0]";
             "(f [2 1 0]) -> [1 0]";
            ], []),
    "";

    ("value", ["(f {1}) -> 1";
               "(f {2 {} {}}) -> 2"], []),
    "";

    ("incr", ["(f []) -> []";
              "(f [1]) -> [2]";
              "(f [1 2]) -> [2 3]";
              "(f [1 2 3 4]) -> [2 3 4 5]";
             ], ["1"]),
    "";

    ("incrt", ["(f {}) -> {}";
               "(f {1}) -> {2}";
               "(f {1 {2}}) -> {2 {3}}";
              ], ["1"]),
    "";

    ("incrs", ["(f []) -> []";
               "(f [[1]]) -> [[2]]";
               "(f [[1] [2]]) -> [[2] [3]]";
               "(f [[1 2] [3 4]]) -> [[2 3] [4 5]]";
              ], ["1"]),
    "";

    ("sumt", ["(f {}) -> 0";
              "(f {1}) -> 1";
              "(f {1 {2} {3}}) -> 6";
             ], ["0"]),
    "";

    (* ("flatten", ["(f {}) -> []"; *)
    (*              "(f {1}) -> [1]"; *)
    (*              "(f {1 {2} {3}}) -> [1 2 3]"; *)
    (*             ], []), *)
    (* ""; *)

    ("add", ["(f [] 1) -> []";
             "(f [1] 1) -> [2]";
             "(f [1 2] 1) -> [2 3]";
             "(f [1 2] 2) -> [3 4]";
             "(f [1 2 3 4] 5) -> [6 7 8 9]";
            ], []),
    "";

    ("evens", ["(f []) -> []";
               "(f [1]) -> []";
               "(f [1 2]) -> [2]";
               "(f [1 2 3 4]) -> [2 4]";
              ], ["0"; "1"]),
    "";

    ("zeroes", ["(f []) -> []";
                "(f [0]) -> []";
                "(f [1 0]) -> [1]";
                "(f [1 0 2]) -> [1 2]";
               ], ["0"]),
    "";

    ("concat", ["(f [] []) -> []";
                "(f [0] []) -> [0]";
                "(f [1 0] [0]) -> [1 0 0]";
                "(f [1 0 2] [3 4]) -> [1 0 2 3 4]";
               ], []),
    "";

    ("sums", ["(f []) -> []";
              "(f [[]]) -> [0]";
              "(f [[1] []]) -> [1 0]";
              "(f [[1 2] [3 4]]) -> [3 7]";
             ], []),
    "";

    ("reverse", ["(f []) -> []";
                 "(f [0]) -> [0]";
                 "(f [0 1]) -> [1 0]";
                 "(f [0 1 2]) -> [2 1 0]"
                ], []),
    "";

    ("last", ["(f [1]) -> 1";
              "(f [1 2]) -> 2";
              "(f [1 2 3]) -> 3";
              "(f [1 3 5 8]) -> 8"
             ], []),
    "";

    ("length", ["(f []) -> 0";
                "(f [0]) -> 1";
                "(f [0 0]) -> 2";
                "(f [0 0 0]) -> 3";
               ], ["1"]),
    "";

    ("join", ["(f []) -> []";
              "(f [[] [1 0]]) -> [1 0]";
              "(f [[1 0] []]) -> [1 0]";
              "(f [[1 0] [2 3] [6] [4 5]]) -> [1 0 2 3 6 4 5]";
             ], []),
    "";

    (* ("count", ["(f [] 1) -> 0"; *)
    (*            "(f [1 0] 1) -> 1"; *)
    (*            "(f [0 0 1] 0) -> 2"; *)
    (*            "(f [1 2 2 2 4 4 5] 2) -> 3"; *)
    (*            "(f [1 2 2 2 4 4 5] 4) -> 2"; *)
    (*            "(f [1 2 2 2 4 4 5] 5) -> 1"; *)
    (*           ], ["0"; "1"]), *)
    (* ""; *)

    ("max", ["(f []) -> 0";
             "(f [0]) -> 0";
             "(f [0 2 1]) -> 2";
             "(f [1 6 2 5]) -> 6";
             "(f [1 6 7 5]) -> 7";
            ], []),
    "";

    (* ("cprod", ["(f []) -> [[]]"; *)
    (*            "(f [[]]) -> []"; *)
    (*            "(f [[] []]) -> []"; *)
    (*            "(f [[1 2 3] [4] [5 6]]) -> [[1 4 5] [1 4 6] [2 4 5] [2 4 6] [3 4 5] [3 4 6]]"; *)
    (*           ], []), *)
    (* ""; *)


    (* ("power", ["(f []) -> [[]]"; *)
    (*            "(f [0]) -> [[] [0]]"; *)
    (*            "(f [0 1]) -> [[] [1] [0] [0 1]]"; *)
    (*           ], []), *)
    (* ""; *)

    ("multfirst", ["(f []) -> []";
                   "(f [1 0]) -> [1 1]";
                   "(f [0 1 0]) -> [0 0 0]";
                   "(f [2 0 2 3]) -> [2 2 2 2]";
                  ], []),
    "";

    ("multlast", ["(f []) -> []";
                  "(f [1 0]) -> [0 0]";
                  "(f [0 1 0]) -> [0 0 0]";
                  "(f [2 0 2 3]) -> [3 3 3 3]";
                 ], []),
    "";

    ("append", ["(f [] 1) -> [1]";
                "(f [] 2) -> [2]";
                "(f [1 0] 2) -> [1 0 2]";
               ], ["[]"]),
    "";

    ("average", ["(sum []) -> 0";
                 "(sum [1]) -> 1";
                 "(sum [1 2 3]) -> 6";
                 "(sum [1 1 1 1]) -> 4";
                 "(length []) -> 0";
                 "(length [0]) -> 1";
                 "(length [0 0]) -> 2";
                 "(length [0 0 0]) -> 3";
                 "(average [0]) -> 0";
                 "(average [0 1 5]) -> 2";
                 "(average [1 1 1 1]) -> 1";
                 "(average [4 5 7 8]) -> 6";
                ], ["1"]),
    "";

    ("dropaverage", ["(sum []) -> 0";
                     "(sum [1]) -> 1";
                     "(sum [1 2 3]) -> 6";
                     "(sum [1 1 1 1]) -> 4";
                     "(length []) -> 0";
                     "(length [0]) -> 1";
                     "(length [0 0]) -> 2";
                     "(length [0 0 0]) -> 3";
                     "(average [0]) -> 0";
                     "(average [0 1 5]) -> 2";
                     "(average [1 1 1 1]) -> 1";
                     "(average [4 5 7 8]) -> 6";
                     "(dropaverage [0 1 5]) -> [5]";
                     "(dropaverage [1 1 1 1]) -> [1 1 1 1]";
                     "(dropaverage [4 5 7 8]) -> [7 8]";
                    ], ["1"]),
    "";

    ("dropmax", ["(max []) -> 0";
                 "(max [0]) -> 0";
                 "(max [0 2 1]) -> 2";
                 "(max [1 6 2 5]) -> 6";
                 "(max [1 6 7 5]) -> 7";
                 "(dropmax [3 5 2]) -> [3 2]";
                 "(dropmax [3 1 2]) -> [1 2]";
                 "(dropmax [1 5 2]) -> [1 2]";
                ], ["0"]),
    "";

    ("shiftl", ["(append [] 1) -> [1]";
                "(append [] 2) -> [2]";
                "(append [1 0] 2) -> [1 0 2]";

                "(shiftl []) -> []";
                "(shiftl [1]) -> [1]";
                "(shiftl [1 2]) -> [2 1]";
                "(shiftl [1 2 3]) -> [3 2 1]";
                "(shiftl [1 2 3 4]) -> [2 3 4 1]";
    ], ["[]"]),
    "";

    ("member", ["(f [] 0) -> #f";
                "(f [0] 0) -> #t";
                "(f [0] 1) -> #f";
                "(f [0 1 0] 0) -> #t";
                "(f [0 1 0] 1) -> #t";
                "(f [1 6 2 5] 2) -> #t";
                "(f [5 6 2] 6) -> #t";
                "(f [1 2 5] 3) -> #f";
               ], ["#f"]),
    "";

    (* ("insert", ["(f [] 1) -> [1]"; *)
    (*             "(f [] 2) -> [2]"; *)
    (*             "(f [0 1] 2) -> [0 1 2]"; *)
    (*             "(f [0 1] 1) -> [0 1 1]"; *)
    (*             "(f [0 1] 0) -> [0 0 1]"; *)
    (*             "(f [0 1 2] 0) -> [0 0 1 2]"; *)
    (*            ], ["[]"]), *)
    (* ""; *)

    (* ("drop", ["(f [] 0) -> []"; *)
    (*           "(f [1] 0) -> [1]"; *)
    (*           "(f [] 1) -> []"; *)
    (*           "(f [] 2) -> []"; *)
    (*           "(f [0 1] 0) -> [0 1]"; *)
    (*           "(f [0 1] 1) -> [1]"; *)
    (*           "(f [0 1] 2) -> []"; *)
    (*           "(f [1 1 1] 0) -> [1 1 1]"; *)
    (*           "(f [1 1 1] 1) -> [1 1]"; *)
    (*           "(f [1 1 1] 2) -> [1]"; *)
    (*           "(f [1 1 1] 3) -> []"; *)
    (*            ], ["[]"]), *)
    (* "(if (= 0 n) l (drop (cdr l) (- n 1)))"; *)

    (* ("frequency", ["(f [1]) -> [1]"; *)
    (*                "(f [1 2]) -> [1 1]"; *)
    (*                "(f [1 2 1]) -> [2 1 2]"; *)
    (*               ], ["0"]), *)
    (* ""; *)
  ]

let time_solve ((name, example_strs, init_strs), _) =
  let examples = List.map example_strs ~f:Util.parse_example in
  let init = List.map init_strs ~f:Util.parse_expr in
  begin
    let start_time = Time.now () in
    let solutions = Search.solve examples ~init:init in
    let end_time = Time.now () in
    let solve_time = Time.diff end_time start_time in
    let solutions_str =
      Ast.Ctx.to_alist solutions
      |> List.map ~f:(fun (name, lambda) ->
                      let lambda = Ast.normalize_expr lambda in
                      "\t\t" ^ (Ast.expr_to_string (`Let (name, lambda, `Id "_"))))
      |> String.concat ~sep:"\n"
    in
    Printf.printf "Solved %s in %s.\n" name (Time.Span.to_short_string solve_time);
    Printf.printf "\tSolutions:\n%s\n\n" solutions_str;
    flush stdout;
  end

let () =
  Printf.printf "Running test cases...\n";
  List.iter catamorphic_solve_testcases ~f:time_solve
