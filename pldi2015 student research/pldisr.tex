% Created 2015-03-14 Sat 23:42
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{fullpage}
\usepackage{xspace}

\author{John Feser advised by Swarat Chaudhuri}
\date{\today}
\title{Applications of Automated Deduction to Program Synthesis}

\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.4.90.1 (Org mode 8.2.10)}}

\newcommand{\sys}{$\lambda^2$\xspace}

\begin{document}

\maketitle

\section{Problem and motivation}
\label{sec-1}

This research is intended to improve the performance of
\sys~\cite{l2}, which is a system for synthesizing data structure
manipulation programs from input-output examples.\@ \sys performs well
for many problems, but it has a limited set of operators, which
restricts the set of programs that it can synthesize. Recent work in
synthesis has explored the possibility of making the set of operators
a parameter of the synthesizer~\cite{component}. This suggests that
one way to extend the capabilities of \sys is to pass in a larger set
of operators that give it additional functionality. However, this
approach has a fundamental problem: increasing the size of the
operator set causes a combinatorial explosion of the size of the
search space. This work describes a method for using automated
deduction to prune the search space. This new method is more powerful
than the techniques currently used by \sys and may allow the operator
set to be scaled up while maintaining reasonable performance.

\section{Background}
\label{sec-2}

\sys is implemented as a search procedure over the space of
programs. Its target language is a dialect of the lambda calculus,
with recursive let and a set of operators over integers, booleans,
lists and trees. It examines programs in order of cost, where cost is
a metric that increases monotonically with the size of the program
AST.\@ The search is performed by repeatedly generalizing an abstract
hypothesis or ``skeleton'' program. An abstract hypothesis is a term
in the lambda calculus that contains free variables. Generalizing a
hypothesis replaces one of the free variables with a new
hypothesis. We call a hypothesis without free variables
\emph{concrete}. When a concrete hypothesis is generated, it is
verified by checking it against the input-output examples.

The set of programs that \sys searches can be visualized as a tree
rooted at some initial hypothesis. The children of a node are those
hypotheses that can be created by generalizing one of the holes in the
node. In this tree, abstract hypotheses are interior nodes and
concrete hypotheses are leaves. \sys attempts to search as little of
the tree as possible by using deductive reasoning to prune away
branches that it can prove will produce no viable solutions.

The original version of \sys uses a lightweight form of deduction that
requires hand coded deductive rules for each of the included
operators. Those rules allow \sys to avoid examining syntactically
different but semantically identical expressions as well as allowing
it to prune away some sets of infeasible solutions. \sys was not
intended to be component based, so it includes only a small set of
operators. Therefore, it was reasonable to hard-code knowledge about
each operator. Although custom reasoning works when the operator set
is small, it becomes less feasible as the set of operators increases
in size.

\section{Approach}
\label{sec-3}

This research is aimed at finding a better technique for pruning the
search tree than the methods \sys currently uses. The key insight
behind this new approach is that to prune a branch of the search tree,
we need to solve a higher-order unification problem. Specifically,
given an abstract hypothesis $H$ with some holes $x_1 \dots x_n$ and
an input-output tuple $(i, o)$, we would like to prove that there is
no assignment
$\sigma = \{x_1 \leftarrow y_1 \dots x_n \leftarrow y_n\}$ to the
holes in $H$ such that $H[\sigma](i) = o$. $H$ can be an arbitrary
lambda calculus term. Higher-order unification is undecidable in
general~\cite{huet-undecidability}, so we approximate the solution
using an SMT solver.\@ We can avoid solving the unification problem
directly because we are not interested in finding a unifier. Rather,
we wish to prove that no unifier exists.

For example, consider the hypothesis $f = \lambda x.~\text{cons}~g~x$,
generated by \sys while synthesizing a function to duplicate each
element in a list. If the user has provided an example
$[1, 2] \rightarrow [1, 1, 2, 2]$, we would like to solve the higher
order unification problem
$\exists g: (\lambda x.~\text{cons}~g~x) [1, 2] = [1, 1, 2, 2]$. We
can use an SMT solver to solve this problem if we know the following
lemma about cons:
$\forall x, l: \text{length}(\text{cons}~x~l) = (\text{length}~l) +
1$.
Using the lemma and the example provided by the user, we can transform
the original problem into
\(\exists x : \text{length}(\text{cons}~x~l_i) = (\text{length}~l_i) +
1 \land \text{cons}~x~l_i = l_o \land \text{length}~l_i = 2 \land
\text{length}~l_o = 4\).
The resulting formula can be efficiently solved by an SMT solver which
supports the theory of uninterpreted functions. In this case, the
formula is unsatisfiable, so \sys can prune the subtree rooted at
hypothesis $f$.

The SMT approximation requires lemmas about the operators used in the
hypothesis. At the moment, we are providing those lemmas manually for
each operator. In future, we would like to generate lemmas
automatically for the operators in our operator set.

\section{Results}
\label{sec-4}

To test this idea, we produced a prototype implementation which
integrates Z3~\cite{z3} with \sys and tested it using a set of
standard list manipulation operators in addition to the operators that
\sys provides by default. The intention was to trigger the
combinatorial explosion problem that \sys suffers from and to
determine how much improving its deduction helps.

Our preliminary results show that integrating an SMT solver into \sys
reduces the number of expressions verified by the system by
approximately 15\% on the set of problems that we tried. At the
moment, this does not translate into a performance increase, because
the overhead of calling the solver outweighs the cost of verifying the
additional expressions. However, the set of lemmas that we currently
use is very restricted. Increasing the number of lemmas will allow us
to prune more effectively. Ultimately, we believe that improving the
deduction used in \sys is essential to being able to scale the size of
our operator set, and that large operator sets are key to being able
to synthesize interesting programs.

This research is ongoing, and future work will focus on improving the
system's performance, but also on integrating a larger set of
operators into \sys to better test its scaling capabilities.

\bibliography{pldisr.bib}
\bibliographystyle{unsrt}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
