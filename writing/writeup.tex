\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{listings}
\tolerance=1000
\usepackage{fullpage}
\author{Jack Feser}
\date{\today}
\title{Writeup}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.7c)}}
\begin{document}
\lstset{language=ML}

\tableofcontents

\section{Overview}
\label{sec-1}
Our algorithm uses a novel combination of generalization, deduction,
and search to synthesize recursive programs from input-output
examples. An inductive generalization step is used to obtain a finite
set of ``code skeletons'', each of which forms a class of potential
implementations. The skeletons contain holes which can be searched for
exhaustively.

\section{Inductive generalization}
\label{sec-2}
The inductive generalization step takes a set of input-output examples
and produces a ``code skeleton.'' This ``skeleton'' is a program
structure that uses only higher order functions (map, fold, filter,
etc.) and contains holes, which are filled recursively. Using higher
order functions to encapsulate the synthesized program's recursion
scheme helps keep the search space manageable. The current
implementation has a fixed depth limit

When possible, input-output examples are deduced for each hole in the
skeleton. This deduction process is performed in an ad-hoc way and is
specific to the higher order function that is being used. For example,
if we have a skeleton $\lambda x\,.\,map~x~f$ which has an
input-output example $[1, 2] \rightarrow [3, 4]$ we can deduce that
$f$ has two input-output examples $1 \rightarrow 3$ and $2 \rightarrow
4$. The example deduction process is sound; the generated examples
will never cause the inductive generalization process to reject a
correct skeleton. However, the deduction process is incomplete. When
filling in a hole it is not sufficient to satisfy the examples for
that hole. The examples for the program skeleton as a whole must be
checked as well.

The deduced examples are used to prune the recursion tree of the
inductive generalization step. For example, if we are synthesizing the
function reverse, we might have the example $[1,1,2] \rightarrow
[2,1,1]$. Starting from an initial skeleton $\lambda x\,.\,f~x$, $f$
has the type signature $list[a] \rightarrow list[a]$. Following the
type signature, the generalization step would attempt to generate a
new skeleton $\lambda x\,.\,map~x~g$. The following examples would be
deduced for $g$: $1 \rightarrow 2$, $1 \rightarrow 1$, $2 \rightarrow
1$. Obviously there is no pure implementation of $g$, so it is safe to
disregard this skeleton.

In the implementation, this process is a little more complicated
because examples have a context. The context contains the values of
variables that are accessible from outer scopes. In the example above,
each of the deduced examples for $g$ would be paired with the context
$\{x:[1,1,2]\}$. This is important because while holes are required to
be implemented purely, they are not required to be functions. It is
often useful to be able to use values from outer scopes and it would
clash badly with the use of higher order functions to require these
variables to be passed as parameters. To eliminate a skeleton, there
must exist a pair of examples $x_1 \rightarrow y_1, c_1$, $x_2
\rightarrow y_2, c_2$ such that $x_1 = x_2 \land y_1 \land y_2 \land
c_1 = c_2$.

\section{Deduction}
\label{sec-3}
The example deduction step is currently implemented in an ad-hoc way
for each combinator. In fact, since the only requirement for
correctness is that the examples be consistent, a procedure that
returns the empty list is fully correct. We can usually do better, but
not always. In particular, deducing examples for folds is difficult.

$map$ is the simplest combinator to deduce examples for. Let $\lambda
x\,.\,f~x$ be a skeleton where $E_f$ is the set of examples for
$f$. To generate a new skeleton where $f$ is implemented with $map$,
$\lambda x\,.\,map~x~g$, we need to deduce a set of examples
$E_g$. Examples can be deduced for $g$ iff all examples in $E_f$ are
of the form $[a_1; a_2; \dots; a_n] \rightarrow [b_1; b_2; \dots;
b_n]$. In this case,

\[E_g = \bigcup_{[a_1; a_2; \dots; a_n] \rightarrow [b_1; b_2; \dots;
  b_n] \in E_f} \{a_1 \rightarrow b_1, a_2 \rightarrow b_2, \dots, a_n
\rightarrow b_n\}\]

Deducing examples for $filter$ requires a different process. Let
$\lambda x\,.\,f~x$ be a skeleton where $E_f$ is the set of examples
for $f$. To generate a new skeleton where $f$ is implemented with
$filter$, $\lambda x\,.\,filter~x~g$, we need to deduce a set of
examples $E_g$. Examples can be deduced for $g$ iff all examples in
$E_f$ are of the form $[a_1; a_2; \dots; a_n] \rightarrow [b_1; b_2;
\dots; b_m]$ where $n \geq m$ and $\forall b : \exists a : a = b$. In
this case,

\[E_g = \bigcup_{A \rightarrow B \in E_f} \{x \rightarrow \#t
~|~x \in A \land x \in B\} \cup \{x \rightarrow \#f ~|~x \in A \land x
\notin B\}\]

$foldl$ and $foldr$ are trickier to deduce examples for. Consider for
example the $sum$ function for lists. Let $sum = \lambda
x\,.\,foldl~x~g$. The user might provide the following examples, for
which we can make the following deductions about $g$:

\begin{align*}
[] &\rightarrow 0 \\
[1] &\rightarrow 1 \Rightarrow g~0~1 = 1 \\
[1; 2] &\rightarrow 3 \Rightarrow g~(g~0~1)~2 = 3 \\
[1; 2; 3] &\rightarrow 6 \Rightarrow g~(g~(g~0~1)~2)~3 = 6 \\
[2; 3] &\rightarrow 5 \Rightarrow g~(g~0~2)~3 = 5 \\
[2; 3; 5] &\rightarrow 10 \Rightarrow g~(g~(g~0~2)~3)~5 = 10 \\
\end{align*}

In the first case, $g$ is never invoked, so the example provides no
information about it. In the next three cases it is possible to
simplify the equation so that $g$ is applied to two constants. The
fourth case is impossible to simplify since we do not know the value
of $g~0~2$. The last case, however, is simplifiable, because
$g~(g~0~2)~3 = 5$ is provided by the fourth case. From these examples,
we can deduce that $E_g = \{0~1 \rightarrow 1, 1~2 \rightarrow 3, 3~3
\rightarrow 6\, 5~5 \rightarrow 10\}$. The examples in $E_g$ are
consistent, but they are not complete. There is information provided
by the user's specification of $sum$ that is not captured in the
examples for $g$.

Practically, when deducing examples for $foldl$ and $foldr$, our
implementation first attempts to determine the base case of the fold,
which it uses to build the equations shown above. To find a base case,
we select all examples that have $[]$ as their LHS. If those examples
have the same RHSs, the value of the RHS is assumed to be the base. If
no constant base case can be determined, no examples are generated for
the lambda function. This is still correct, but restricts the amount
of pruning that can be performed in later steps. It is also possible
that the base case could not be a constant. We currently generate two
skeletons: one which assumes the base case to be whatever was
determined, and one which has a extra hole for the base case. In
almost all practical cases, there is a constant base case, but
correctness mandates that we generate this second skeleton. If there
is no constant base case, we only generate the skeleton that has a
hole for it.

The last supported combinator is general recursion. This combinator
assumes captures functions of the following form:

\begin{lstlisting}
let f = function
 | []    -> g []
 | x::xs -> h x xs
\end{lstlisting}

$g$ and $h$ are holes for the base and recursive cases. The general
recursion combinator is special because it binds $f$ in the context
associated with $h$. This allows $h$ to make recursive calls to
$f$. In all the other combinators, recursion is only performed by the
higher-order function. Having general recursion is useful, because it
allows our algorithm to potentially find programs that have unusual
recursion schemes. However, allowing general recursion presents some
practical problems, the most difficult of which is that many
implementations of $f$ will not terminate. The current implementation
simply caps the recursion depth while verifying. If a candidate
program exceeds that depth limit, it is assumed to be incorrect. This
is not a correct assumption in all cases, but it works well in
practice.

\section{Search}
\label{sec-4}
The exhaustive search is implemented using Spivey's combinators for
breadth-first search (Spivey, 1998). Each hole in the program skeleton
has a type signature, so when filling that hole the search is pruned
to only include expressions with the correct type signature. Using a
top-down search makes it easy to only generate expressions with a
specific type. Using Spivey's technique, the we generate a lazy,
infinite stream of candidate expressions that all have the correct
type. Expressions are generated in order of increasing size, measured
as the number of nodes in the expression's AST.

In addition to pruning by type, the search algorithm uses a rewrite
system to eliminate equivalent expressions. The rewrite system takes
an expression and returns either the original expression or an
equivalent, smaller expression. The search is complete, so if an
expression can be rewritten in a smaller form, the equivalent
expression must have been explored earlier in the search. This kind of
pruning is powerful because the search algorithm is recursive. For
example, enumerating all expressions of type $list[num]$ involves
enumerating all expressions of type $num$. Even though it is
impossible to prevent equivalent expressions from being searched,
pruning them away can significantly reduce the search space.

In the implementation, expression streams are memoized to reduce
memory use. However, this means that expressions that have already
been evaluated cannot be discarded.

\section{Experiments}

\begin{lstlisting}
Solved dupli in 259ms. Solutions:
	(let dupli (lambda (a) (foldr a (lambda (c b) (cons b (cons b c))) [])) _)

Solved car in 988us. Solutions:
	(let mycar (lambda (a) (foldr a (lambda (c b) b) 0)) _)

Solved cdr in 851us. Solutions:
	(let mycdr (lambda (a) (let b (lambda (c) (if (= c []) [] ((lambda (e d) d) (car c) (cdr c)))) (b a))) _)

Solved value in 843us. Solutions:
	(let myvalue (lambda (a) (foldt a (lambda (c b) b) 0)) _)

Solved incr in 20ms. Solutions:
	(let incr (lambda (a) (map a (lambda (b) (+ 1 b)))) _)

Solved incrt in 4.5ms. Solutions:
	(let incrt (lambda (a) (mapt a (lambda (b) (+ 1 b)))) _)

Solved incrs in 44ms. Solutions:
	(let incrs (lambda (a) (map a (lambda (b) (map b (lambda (c) (+ 1 c)))))) _)

Solved sumt in 15ms. Solutions:
	(let sumt (lambda (a) (foldt a (lambda (c b) (foldl c (lambda (e d) (+ e d)) b)) 0)) _)

Solved flatten in 102ms. Solutions:
	(let flatten (lambda (a) (foldt a (lambda (c b) (cons b (join c))) [])) _)
	(let join (lambda (a) (foldl a (lambda (c b) (foldr c (lambda (e d) (cons d e)) b)) [])) _)

Solved add in 17ms. Solutions:
	(let add (lambda (b a) (map b (lambda (c) (+ a c)))) _)

Solved evens in 9.6s. Solutions:
	(let evens (lambda (a) (filter a (lambda (b) (= 0 (% b (+ 1 1)))))) _)

Solved zeroes in 26ms. Solutions:
	(let zeroes (lambda (a) (filter a (lambda (b) (!= 0 b)))) _)

Solved concat in 224ms. Solutions:
	(let concat (lambda (b a) (foldl b (lambda (d c) (foldr b (lambda (f e) (cons e f)) a)) [])) _)

Solved sums in 36ms. Solutions:
	(let sums (lambda (a) (map a (lambda (b) (foldl b (lambda (d c) (+ d c)) 0)))) _)

Solved reverse in 17ms. Solutions:
	(let reverse (lambda (a) (foldl a (lambda (c b) (cons b c)) [])) _)

Solved last in 526us. Solutions:
	(let last (lambda (a) (foldl a (lambda (c b) b) 0)) _)

Solved length in 16ms. Solutions:
	(let length (lambda (a) (foldl a (lambda (c b) (+ 1 c)) 0)) _)

Solved join in 74ms. Solutions:
	(let join (lambda (a) (foldl a (lambda (c b) (foldr c (lambda (e d) (cons d e)) b)) [])) _)

Solved max in 4.5s. Solutions:
	(let max (lambda (a) (foldl a (lambda (c b) (if (< c b) b c)) 0)) _)

Solved height in 4.6s. Solutions:
	(let height (lambda (a) (foldt a (lambda (c b) (+ 1 (max c))) 0)) _)
	(let max (lambda (a) (foldl a (lambda (c b) (if (< c b) b c)) 0)) _)

Solved multfirst in 2.3ms. Solutions:
	(let multfirst (lambda (a) (foldr a (lambda (c b) (map a (lambda (d) b))) [])) _)

Solved multlast in 41ms. Solutions:
	(let multlast (lambda (a) (foldl a (lambda (c b) (foldl a (lambda (e d) (cons b e)) [])) [])) _)

Solved append in 1.3s. Solutions:
	(let append (lambda (b a) (foldr b (lambda (d c) (cons c d)) (cons a []))) _)

Solved average in 4s. Solutions:
	(let average (lambda (a) (/ (sum a) (length a))) _)
	(let length (lambda (a) (foldl a (lambda (c b) (+ 1 c)) 0)) _)
	(let sum (lambda (a) (foldl a (lambda (c b) (+ c b)) 0)) _)

Solved dropaverage in 4.5s. Solutions:
	(let average (lambda (a) (/ (sum a) (length a))) _)
	(let dropaverage (lambda (a) (filter a (lambda (b) (<= (average a) b)))) _)
	(let length (lambda (a) (foldl a (lambda (c b) (+ 1 c)) 0)) _)
	(let sum (lambda (a) (foldl a (lambda (c b) (+ c b)) 0)) _)

Solved dropmax in 4.8s. Solutions:
	(let dropmax (lambda (a) (filter a (lambda (b) (!= b (max a))))) _)
	(let max (lambda (a) (foldl a (lambda (c b) (if (< c b) b c)) 0)) _)

Solved shiftl in 1.2s. Solutions:
	(let append (lambda (b a) (foldr b (lambda (d c) (cons c d)) (cons a []))) _)
	(let shiftl (lambda (a) (let b (lambda (c) (if (= c []) [] ((lambda (e d) (append d e)) (car c) (cdr c)))) (b a))) _)

Solved shiftr in 22s. Solutions:
	(let last (lambda (a) (foldl a (lambda (c b) b) 0)) _)
	(let shiftr (lambda (a) (foldr a (lambda (c b) (foldl c (lambda (e d) (cons (last a) (cons b (cdr c)))) [1])) [])) _)

Solved member in 754ms. Solutions:
	(let member (lambda (b a) (foldl b (lambda (d c) (| d (= a c))) #f)) _)

Solved dedup in 1.8m. Solutions:
	(let dedup (lambda (a) (foldr a (lambda (c b) (if (member c b) c (cons b c))) [])) _)
	(let member (lambda (b a) (foldl b (lambda (d c) (| d (= a c))) #f)) _)
\end{lstlisting}

\label{sec-5}
\end{document}
